function init(self)
    msg.post(".", "acquire_input_focus")
    self.moving = false
    self.current_animation = "idle"
    self.speed = 120  -- Horizontal movement speed
    self.direction_x = 0
    self.keys_pressed = {}
    
    -- Physics properties
    self.velocity_y = 0         -- Vertical velocity
    self.gravity = -800         -- Gravity force (pixels/second^2)
    self.base_jump_force = 450  -- Base jump initial velocity (increased from 300)
    self.jump_multiplier = 1.0  -- Jump power multiplier (for future power-ups)
    self.ground_y = 55          -- Ground level (same as spawn Y)
    self.on_ground = true       -- Whether player is on ground
    
    -- Screen boundaries (with small margin for sprite size)
    self.screen_left = 20       -- Left boundary
    self.screen_right = 940     -- Right boundary (960 - 20)
    self.screen_bottom = 0      -- Bottom boundary
    self.screen_top = 640       -- Top boundary
    
    -- Platform definitions (level 2)
    self.platforms = {
        {x1 = 41, x2 = 180, y = 250, name = "platform1"},
        {x1 = 41, x2 = 180, y = 136, name = "platform2"}, 
        {x1 = 310, x2 = 508, y = 136, name = "platform3"},
        {x1 = 228, x2 = 290, y = 88, name = "platform4"},
        {x1 = 110, x2 = 140, y = 316, name = "train_platform"}
    }
    
    -- Player sprite dimensions (scaled to 30%)
    self.player_width = 216 * 0.3   -- About 65 pixels
    self.player_height = 330 * 0.3  -- About 99 pixels
    
    -- Jump debug tracking
    self.jump_started = false
    self.jump_max_y = 0
    self.jump_start_pos = vmath.vector3()
    
    -- Debug: Print initial position
    local pos = go.get_position()
    print(string.format("DEBUG PLAYER: Initial position in player init: (%.1f, %.1f)", pos.x, pos.y))
end

function update(self, dt)
    local pos = go.get_position()
    
    -- Jump debug tracking
    if self.velocity_y > 0 and not self.jump_started then
        -- Jump just started
        self.jump_started = true
        self.jump_max_y = pos.y
        self.jump_start_pos = vmath.vector3(pos)
        print(string.format("ðŸš€ JUMP STARTED from (%.1f, %.1f)", pos.x, pos.y))
    elseif self.jump_started and self.velocity_y > 0 then
        -- Tracking jump height
        self.jump_max_y = math.max(self.jump_max_y, pos.y)
    elseif self.jump_started and self.velocity_y <= 0 and self.on_ground then
        -- Jump ended (landed)
        print(string.format("ðŸŽ¯ JUMP MAX: Player reached (%.1f, %.1f) - Height gained: %.1f pixels", 
              pos.x, self.jump_max_y, self.jump_max_y - self.jump_start_pos.y))
        self.jump_started = false
    end
    
    -- Apply gravity
    self.velocity_y = self.velocity_y + self.gravity * dt
    
    -- Apply horizontal movement with boundary checking
    if self.direction_x ~= 0 then
        local new_x = pos.x + self.direction_x * self.speed * dt
        -- Clamp to screen boundaries
        new_x = math.max(self.screen_left, math.min(self.screen_right, new_x))
        pos.x = new_x
        self.moving = true
    else
        self.moving = false
    end
    
    -- Apply vertical movement (gravity/jumping)
    pos.y = pos.y + self.velocity_y * dt
    
    -- Check platform and ground collisions
    local collision_y = check_platform_collision(self, pos)
    if collision_y then
        pos.y = collision_y
        self.velocity_y = 0
        self.on_ground = true
    else
        -- Ground collision as fallback
        if pos.y <= self.ground_y then
            pos.y = self.ground_y
            self.velocity_y = 0
            self.on_ground = true
        else
            self.on_ground = false
        end
    end
    
    -- Clamp vertical position to screen boundaries
    pos.y = math.max(self.screen_bottom, math.min(self.screen_top, pos.y))
    
    -- Update position
    go.set_position(pos)
    
    -- Update animation based on movement
    update_animation(self)
end

function check_platform_collision(self, pos)
    -- Check if player is falling (velocity <= 0 means falling or on surface)
    if self.velocity_y > 0 then
        return nil  -- Player is jumping up, no platform collision
    end
    
    -- Player collision box (center-based)
    local player_left = pos.x - self.player_width / 2
    local player_right = pos.x + self.player_width / 2
    local player_bottom = pos.y - self.player_height / 2
    
    -- Check regular platforms
    for _, platform in ipairs(self.platforms) do
        -- Check horizontal overlap
        if player_right > platform.x1 and player_left < platform.x2 then
            -- Check if player is landing on platform (within small margin)
            if player_bottom <= platform.y + 5 and player_bottom >= platform.y - 5 then
                print(string.format("Platform collision: %s at y=%.1f", platform.name, platform.y))
                return platform.y + self.player_height / 2  -- Position player on top of platform
            end
        end
    end
    
    -- Check train platform collision
    local train_pos = go.get_position("train")
    if train_pos.x > -500 then  -- Train is visible (not hidden offscreen)
        -- Train dimensions (214Ã—165)
        local train_left = train_pos.x - 214 / 2
        local train_right = train_pos.x + 214 / 2
        local train_top = train_pos.y + 165 / 2
        
        -- Check horizontal overlap with train
        if player_right > train_left and player_left < train_right then
            -- Check if player is landing on train top
            if player_bottom <= train_top + 5 and player_bottom >= train_top - 5 then
                print(string.format("Train platform collision at y=%.1f", train_top))
                return train_top + self.player_height / 2  -- Position player on top of train
            end
        end
    end
    
    return nil  -- No platform collision
end

function on_input(self, action_id, action)    
    -- Debug: Log all input
    if action.pressed or action.released then
        print(string.format("DEBUG PLAYER INPUT: %s %s", tostring(action_id), action.pressed and "PRESSED" or "RELEASED"))
    end
    
    -- Handle jumping (up key)
    if action_id == hash("up") then
        if action.pressed and self.on_ground then
            -- Jump! Apply base jump force with multiplier
            self.velocity_y = self.base_jump_force * self.jump_multiplier
            self.on_ground = false
            print(string.format("DEBUG: Jump! Force: %.1f (base: %.1f x multiplier: %.2f)", 
                  self.velocity_y, self.base_jump_force, self.jump_multiplier))
            
            -- Notify zombie about player jump (for tactical pause)
            msg.post("zombie", "player_jumped")
        end
    -- Handle horizontal movement
    elseif action_id == hash("left") then
        if action.pressed then
            self.keys_pressed["left"] = true
        elseif action.released then
            self.keys_pressed["left"] = false
        end
    elseif action_id == hash("right") then
        if action.pressed then
            self.keys_pressed["right"] = true
        elseif action.released then
            self.keys_pressed["right"] = false
        end
    end
    
    update_movement(self)
end

function update_movement(self)
    -- Calculate horizontal direction only
    self.direction_x = 0
    
    if self.keys_pressed["left"] then self.direction_x = -1 end
    if self.keys_pressed["right"] then self.direction_x = 1 end
end

function update_animation(self)
    -- Update animation based on current state
    if not self.on_ground then
        -- In air - show jump animation (use up animation)
        play_animation(self, "up")
    elseif self.direction_x ~= 0 then
        -- Moving horizontally
        play_animation(self, self.direction_x > 0 and "right" or "left")
    else
        -- Standing still
        stop_movement(self)
    end
end

function play_animation(self, animation)
    if self.current_animation ~= animation then
        sprite.play_flipbook("#sprite", animation)
        self.current_animation = animation
        self.moving = true
    end
end

function stop_movement(self)
    if self.moving then
        sprite.play_flipbook("#sprite", "idle")
        self.current_animation = "idle"
        self.moving = false
    end
end

function set_jump_multiplier(self, multiplier)
    -- Function for future power-up system
    self.jump_multiplier = multiplier
    print(string.format("Jump multiplier set to: %.2f", multiplier))
end

function get_jump_info(self)
    -- Debug function to check current jump settings
    return {
        base_force = self.base_jump_force,
        multiplier = self.jump_multiplier,
        effective_force = self.base_jump_force * self.jump_multiplier
    }
end

function on_message(self, message_id, message, sender)
    if message_id == hash("disable_input") then
        -- Stop movement immediately and clear all input state
        self.moving = false
        self.direction_x = 0
        self.keys_pressed = {}  -- Clear all key states
        sprite.play_flipbook("#sprite", "idle")
        self.current_animation = "idle"
        msg.post(".", "release_input_focus")
    elseif message_id == hash("enable_input") then
        -- Re-enable input and acquire focus with clean state
        self.moving = false
        self.direction_x = 0
        self.keys_pressed = {}  -- Ensure clean key state
        self.velocity_y = 0     -- Reset vertical velocity
        self.on_ground = true   -- Reset ground state
        sprite.play_flipbook("#sprite", "idle")  -- Ensure idle animation
        self.current_animation = "idle"
        
        -- Debug: Confirm state reset
        print("DEBUG PLAYER RESTART: State reset - moving:", self.moving, "direction_x:", self.direction_x, "keys_pressed:", #self.keys_pressed)
        
        msg.post(".", "acquire_input_focus")
    elseif message_id == hash("set_jump_multiplier") then
        -- Power-up message for future use
        set_jump_multiplier(self, message.multiplier or 1.0)
    end
end