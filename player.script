function init(self)
    msg.post(".", "acquire_input_focus")
    self.moving = false
    self.current_animation = "idle"
    self.speed = 120  -- Horizontal movement speed
    self.direction_x = 0
    self.keys_pressed = {}
    
    -- Physics properties
    self.velocity_y = 0         -- Vertical velocity
    self.gravity = -800         -- Gravity force (pixels/second^2)
    self.base_jump_force = 450  -- Base jump initial velocity (increased from 300)
    self.jump_multiplier = 1.0  -- Jump power multiplier (for future power-ups)
    self.ground_y = 55          -- Ground level (same as spawn Y)
    self.on_ground = true       -- Whether player is on ground
    
    -- Screen boundaries (with small margin for sprite size)
    self.screen_left = 20       -- Left boundary
    self.screen_right = 940     -- Right boundary (960 - 20)
    self.screen_bottom = 0      -- Bottom boundary
    self.screen_top = 640       -- Top boundary
    
    -- Debug: Print initial position
    local pos = go.get_position()
    print(string.format("DEBUG PLAYER: Initial position in player init: (%.1f, %.1f)", pos.x, pos.y))
end

function update(self, dt)
    local pos = go.get_position()
    
    -- Apply gravity
    self.velocity_y = self.velocity_y + self.gravity * dt
    
    -- Apply horizontal movement with boundary checking
    if self.direction_x ~= 0 then
        local new_x = pos.x + self.direction_x * self.speed * dt
        -- Clamp to screen boundaries
        new_x = math.max(self.screen_left, math.min(self.screen_right, new_x))
        pos.x = new_x
        self.moving = true
    else
        self.moving = false
    end
    
    -- Apply vertical movement (gravity/jumping)
    pos.y = pos.y + self.velocity_y * dt
    
    -- Ground collision
    if pos.y <= self.ground_y then
        pos.y = self.ground_y
        self.velocity_y = 0
        self.on_ground = true
    else
        self.on_ground = false
    end
    
    -- Clamp vertical position to screen boundaries
    pos.y = math.max(self.screen_bottom, math.min(self.screen_top, pos.y))
    
    -- Update position
    go.set_position(pos)
    
    -- Update animation based on movement
    update_animation(self)
end

function on_input(self, action_id, action)    
    -- Handle jumping (up key)
    if action_id == hash("up") then
        if action.pressed and self.on_ground then
            -- Jump! Apply base jump force with multiplier
            self.velocity_y = self.base_jump_force * self.jump_multiplier
            self.on_ground = false
            print(string.format("DEBUG: Jump! Force: %.1f (base: %.1f x multiplier: %.2f)", 
                  self.velocity_y, self.base_jump_force, self.jump_multiplier))
            
            -- Notify zombie about player jump (for tactical pause)
            msg.post("zombie", "player_jumped")
        end
    -- Handle horizontal movement
    elseif action_id == hash("left") then
        if action.pressed then
            self.keys_pressed["left"] = true
        elseif action.released then
            self.keys_pressed["left"] = false
        end
    elseif action_id == hash("right") then
        if action.pressed then
            self.keys_pressed["right"] = true
        elseif action.released then
            self.keys_pressed["right"] = false
        end
    end
    
    update_movement(self)
end

function update_movement(self)
    -- Calculate horizontal direction only
    self.direction_x = 0
    
    if self.keys_pressed["left"] then self.direction_x = -1 end
    if self.keys_pressed["right"] then self.direction_x = 1 end
end

function update_animation(self)
    -- Update animation based on current state
    if not self.on_ground then
        -- In air - show jump animation (use up animation)
        play_animation(self, "up")
    elseif self.direction_x ~= 0 then
        -- Moving horizontally
        play_animation(self, self.direction_x > 0 and "right" or "left")
    else
        -- Standing still
        stop_movement(self)
    end
end

function play_animation(self, animation)
    if self.current_animation ~= animation then
        sprite.play_flipbook("#sprite", animation)
        self.current_animation = animation
        self.moving = true
    end
end

function stop_movement(self)
    if self.moving then
        sprite.play_flipbook("#sprite", "idle")
        self.current_animation = "idle"
        self.moving = false
    end
end

function set_jump_multiplier(self, multiplier)
    -- Function for future power-up system
    self.jump_multiplier = multiplier
    print(string.format("Jump multiplier set to: %.2f", multiplier))
end

function get_jump_info(self)
    -- Debug function to check current jump settings
    return {
        base_force = self.base_jump_force,
        multiplier = self.jump_multiplier,
        effective_force = self.base_jump_force * self.jump_multiplier
    }
end

function on_message(self, message_id, message, sender)
    if message_id == hash("disable_input") then
        -- Stop movement immediately
        self.moving = false
        sprite.play_flipbook("#sprite", "idle")
        self.current_animation = "idle"
        msg.post(".", "release_input_focus")
    elseif message_id == hash("enable_input") then
        -- Re-enable input and acquire focus
        msg.post(".", "acquire_input_focus")
    elseif message_id == hash("set_jump_multiplier") then
        -- Power-up message for future use
        set_jump_multiplier(self, message.multiplier or 1.0)
    end
end