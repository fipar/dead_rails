function init(self)
    msg.post(".", "acquire_input_focus")
    self.moving = false
    self.current_animation = "idle"
    self.speed = 120  -- Reasonable speed, faster than zombie (60)
    self.direction_x = 0
    self.direction_y = 0
    self.keys_pressed = {}
end

function update(self, dt)
    if self.moving and (self.direction_x ~= 0 or self.direction_y ~= 0) then
        local pos = go.get_position()
        
        -- Calculate distance for normalization (like zombie does)
        local distance = math.sqrt(self.direction_x * self.direction_x + self.direction_y * self.direction_y)
        
        -- Move using normalized vector (like zombie approach)
        if distance > 0 then
            local move_x = (self.direction_x / distance) * self.speed * dt
            local move_y = (self.direction_y / distance) * self.speed * dt
            
            pos.x = pos.x + move_x
            pos.y = pos.y + move_y
            
            go.set_position(pos)
        end
    end
end

function on_input(self, action_id, action)    
    if action_id == hash("up") then
        if action.pressed then
            self.keys_pressed["up"] = true
        elseif action.released then
            self.keys_pressed["up"] = false
        end
    elseif action_id == hash("down") then
        if action.pressed then
            self.keys_pressed["down"] = true
        elseif action.released then
            self.keys_pressed["down"] = false
        end
    elseif action_id == hash("left") then
        if action.pressed then
            self.keys_pressed["left"] = true
        elseif action.released then
            self.keys_pressed["left"] = false
        end
    elseif action_id == hash("right") then
        if action.pressed then
            self.keys_pressed["right"] = true
        elseif action.released then
            self.keys_pressed["right"] = false
        end
    end
    
    update_movement(self)
end

function update_movement(self)
    -- Calculate direction vector based on pressed keys
    self.direction_x = 0
    self.direction_y = 0
    
    if self.keys_pressed["up"] then
        self.direction_y = 1
    end
    if self.keys_pressed["down"] then
        self.direction_y = -1
    end
    if self.keys_pressed["left"] then
        self.direction_x = -1
    end
    if self.keys_pressed["right"] then
        self.direction_x = 1
    end
    
    -- Determine if moving and animation
    if self.direction_x ~= 0 or self.direction_y ~= 0 then
        self.moving = true
        
        -- Choose animation based on primary direction
        if math.abs(self.direction_x) > math.abs(self.direction_y) then
            if self.direction_x > 0 then
                play_animation(self, "right")
            else
                play_animation(self, "left")
            end
        else
            if self.direction_y > 0 then
                play_animation(self, "up")
            else
                play_animation(self, "down")
            end
        end
    else
        stop_movement(self)
    end
end

function play_animation(self, animation)
    if self.current_animation ~= animation then
        sprite.play_flipbook("#sprite", animation)
        self.current_animation = animation
        self.moving = true
    end
end

function stop_movement(self)
    if self.moving then
        sprite.play_flipbook("#sprite", "idle")
        self.current_animation = "idle"
        self.moving = false
    end
end

function on_message(self, message_id, message, sender)
    if message_id == hash("disable_input") then
        -- Stop movement immediately
        self.moving = false
        sprite.play_flipbook("#sprite", "idle")
        self.current_animation = "idle"
    elseif message_id == hash("enable_input") then
        -- Re-enable input (movement handled by on_input)
    end
end